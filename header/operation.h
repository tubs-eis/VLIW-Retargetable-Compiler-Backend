// Copyright (c) 2022 Chair for Chip Design for Embedded Computing,
//                    Technische Universitaet Braunschweig, Germany
//                    www.tu-braunschweig.de/en/eis
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT

#ifndef OPERATION_H
#define OPERATION_H 1

#include "virtual_reg.h"
#include <iomanip>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <vector>
// #include <unordered_map>

#include "global.h"
#include "rapidxml-1.13/rapidxml.hpp"

struct VirtualRegisterMapping;

/** @brief an enum to represent the types of Operands (register f.e.) Note Error
 * is overloaded. Poor choice of default Value!!*/
enum OPtype : short {
  Error,
  REG,
  Immediate,
  Imm32,
  Label,
  LabelAddr
}; // if one ot them gets changes here, the optypes array in operation.cpp has
   // to be altert.

static std::string OPtypeStr[] = {"Error", "REG",   "Immediate",
                                  "Imm32", "Label", "LabelAddr"};

#define READ 1
#define WRITE 2
#define READWRITE 3
// #define READWRITEPSEUDOREADWRITE 15
#define READWRITEPSEUDOREAD 7
#define PSEUDOPART 12
#define PSEUDOREAD 4
#define PSEUDOWRITE 8
#define LOWERPART 3

class MO;

/** prints a list of all possible operations to stdout */
void showAllOperations();
/** returns the MO parsed from this line or NULL if there is no MO parseable*/
MO *checkline(const char *line, Processor *pro);

void setInstructionWidth(int width);
int getInstructionWidth();
void setMultipleInstruction(bool allow);
int getBuswr();
void setBuswr(int buswr);
int getForwarding();
void setForwarding(int forwarding);
int getStackRegLatency();
void setStackRegLatency(int latency);
bool *getDefaultDirections();

OPtype getOPtype(char *c);

using namespace std;

/** @brief Basic representation of an operation
 *
 * This is an basic class for any operation which could be possible on the
 * processor. It is used to parse Assembler code lines and generate MO from it.
 * @sa MO
 */
class Operation {
private:
  // if it is at some point not enough to have these four, you have to add
  // another char array here, alter the constructor of Operation, in Kartoffel
  // the getSuffixes Method and in Operation the addSuffix and rename Method.
  /** Immediate name */
  char Imm[5];
  /** Size of data structure ( f.e. _32 ) */
  char Size[5];
  /** Conditional execution */
  char Cond[5];
  /** all other suffixes */
  char Suf[12];

  /** the basic name of this operation */
  char basename[NAMELENGTH + 1];
  /** the name including all suffixes */
  string name;
  /** a representation of the opcode of this operation */
  char opcode[OPCODELENGTH + 1];
  /** a representation of the default values of this operation */
  char defaultValues[OPCODELENGTH + 1];
  /** defines if this is a default operation.( should only be applied to
   * suffixes) */
  bool def;
  /** has to be called after changing one of the suffix fields or name field to
   * generate the complete name of this operation */
  void rename();

  /** the types of the arguments */
  OPtype types[MAXARGNUMBER];
  /** the direction of the arguments. */
  char dir[MAXARGNUMBER];
  /** the number of arguments */
  int argnumber;

  int lengthMultiplier = 1;
  int FuId;

  /** points out if this operation is a branch operation or not. */
  bool branches;
  bool CRBranch;
  /** Latency of this operation. */
  int latency;

  /** If set, there is a dependency between two "calls" of this operation */
  bool selfdependent;
  /** Is this operation fully pipelined (i.e., multiple calls can directly
   * follow each other without latency) */
  bool pipelined;

  bool isX2;
  bool isCS;
  bool isCR;

  /** generates the value out of ASM code. returns a pointer to the end of the
   * read char sequence */
  char *generateArgument(const char *line, char32_t *value, OPtype *arg);

  char *parsePragma(MO *mo, char *line);

public:
  /** @brief Constructor.
   *
   * needs the pointer to a xml-structure with type opp
   */
  Operation(rapidxml::xml_node<> *start, int FUID,
            char *defaultDirections = NULL);
  /** @brief generates an MicroOperation out of a line of ASM-Code.
   *
   * @return NULL if it can't be generated by this Operation
   */
  MO *generateMO(const char *asmline);
  /** @brief adds a Suffix/anything that alters to this Operation
   *
   * The Original operation is not altered, but a new one is generatet and given
   * back. It contains of the Operation together with the suffix. If it is not
   * possible to alter the Operation, then NULL is returned.
   * @return a new altered Operation
   */
  Operation *addSuffix(Operation *op);
  /** @brief returns wheter or not this operation branches to another point.
   *
   * @return true if it branches.
   */
  bool isBranchOperation() { return branches; }
  bool isCRBranchOperation() { return CRBranch; }
  bool isX2Operation() {
    return isX2; // name.find("_X2") != name.npos;
  }
  bool isCSOperation() {
    return isCS; // name.find("CS") != name.npos;
  }
  bool isCROperation() {
    return isCR; // name.find("CR") != name.npos;
  }
  bool isSelfdependent() { return selfdependent; }
  bool isPipelined() { return pipelined; }

  bool isSigned() { return Size[1] != 'U'; }
  int getDataWidth() {
    int i = 0;
    while (i < 5 && (Size[i] < '0' || Size[i] > '9'))
      ++i;
    if (i < 5)
      return atoi(Size + i);
    else
      return 0;
  }
  /** @brief Returns the full name
   *
   * The full name consist of the base name plus every suffix.
   * @return The name
   */
  string getName() const { return name; }

  /** @brief Returns the base name of the operation without any suffixes.
   */
  string getBaseName() const { return basename; }
  //  string getBaseName() { return basename; }

  /** @brief returns the latency for this operation
   *
   * @return The latency in cycles.
   */
  int getLatency() const { return latency; }

  /** @brief Sets the latency for this operation
   *
   * normally not necessary, but is used, for setting the latency of a block of
   * Operation inside a FU. setting the latency after creating the MO has no
   * effect on the program, since the MO's have their own latency.
   *
   *  @param lat The new latency.
   */
  void setLatency(int lat) { this->latency = lat; }
  /** @brief returns the Multiplier of this Operation.
   *
   * If an Operation uses more then one issue slot, because its opcode is a
   * multiple of the codesize, then its multiplier is higher then 1. This
   * function returns the number of issueslots which are needed to execute the
   * operation.
   * @return Number of issue slots.
   */
  int opLengthMultiplier() const { return lengthMultiplier; }
  /** @brief Writes a binary representation of the MO to the given outputstream.
   *
   * A binary representation of the of the compiled code is written to the
   * outputstream. The arguments of an MO are combined with the opcode of this
   * operation and insertet at the right places.
   *
   * @param out An output stream. Should be to a file.
   * @param m A microoperation for the arguments
   */
  void writeOutBin(ostream &out, MO *m);
  /** @brief Writes human readable representation of the parsed SLM's to the
   * given outputstream.
   *
   * A human readable representation of the the compiled code is written to the
   * outputstream. The arguments of an MO are combined with the opcode of this
   * operation and insertet at the right places.
   *
   * @param out An output stream. Could be std::out.
   * @param m A microoperation for the arguments
   */
  void writeOutReadable(ostream &out, const MO *m,
                        const VirtualRegisterMap *mapping = 0);
  void writeOutCompilable(ostream &out, const MO *m,
                          const VirtualRegisterMap *mapping = 0);
  std::string to_string(MO *m, VirtualRegisterMap const *mapping = 0);

  /** \brief Returns the Condition part of the operation name. */
  char *getCond() { return Cond; }

  int getFuId() { return FuId; }

  char *getSize() { return Size; }

  /** for nice printing out*/
  friend ostream &operator<<(ostream &cout, const Operation &op) {
    int i;
    for (i = 0; i < MAXARGNUMBER; i++)
      cout << OPtypeStr[op.types[i]] << " ";
    return cout << std::setw(NAMELENGTH + 20) << op.name << "\t(" << op.opcode
                << ")";
  }

  bool isDoubleRegister(const MO *mo, const uint port) const;

  /**
   * Will Throw an exception if accessed wrong!
   * @param mo
   * @param port has to be 0 or 1. To Access Read ports 2 and 3 use different
   * function!
   * @param map
   * @return Returns the physical
   */
  //  template <class T>
  //  int getPhysicalReadPort(const MO *mo, const uint port, const T *map)
  //  const;
  int getPhysicalReadPort(const MO *mo, const uint port,
                          const VirtualRegisterMap *map) const;
  int getPhysicalReadPort(const MO *mo, const uint port,
                          const VirtualAllocation *regMapping) const;
};
// class Operation;

int getEmptyPhysicalReadPort();

char32_t convertRegisterSet(char32_t reg, VirtualRegisterMap const *mapping);

#endif
